{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CubicCraft: A Mesh Stylization Tool","text":"<p>Report  Slides  Demo Video  Code </p> <p>Haoda Li,  Puyuan Yi,  Victor Li,  Zhen Jiang</p> <p> </p> Cubic Craft turns triangle meshes (grey) into cubic-styled meshes (green) <p>In this project, we present a stylization tool to automatically manipulate 3D objects into a cubic style. Our tool provides a GPU implementation for Cubic Stylization [Liu and Jacobson 2019]1, while cubify the object while preserving the geometric details. With our tool, 3D artists can create Minecraft-styled objects with ease. </p>"},{"location":"#install-and-execute","title":"Install and Execute","text":"<p>The code should support all platforms other than Mac M1 chip.</p> <pre><code>git clone https://github.com/haoda-li/CubicCraft.git\ncd CubicCraft\n\npip install -r requirements.txt\ncd main\n\n# If you have a Mac or your computer does not have a GPU\n# change gui_taichi.py line 6 \n# from ti.init(arch=ti.gpu)\n# to ti.init(arch=ti.cpu)\npython gui_taichi.py [PATH TO MESH FILE]\n</code></pre>"},{"location":"#gui-controls","title":"GUI Controls","text":"<ul> <li> <p>Use <code>Preset Camera View</code> to change to the axis-aligned camera view that you like. You can also press <code>w, s, a, d, e, q</code> to move the camera forward, back, left, right, head up, head down, accordingly. In addition, use the right mouse drag to change the camera's viewing angle. </p> </li> <li> <p>Press <code>Enter deformation</code> button and <code>LEFT CLICK</code> the mesh to add new handle points. You can use <code>BACKSPACE</code> on your keyboard to delete currently selected handle point (red) and use <code>TAB</code> to switch to another handle point. By default, one handle is added to the first vertex because cubic stylization needs at least one constraint.</p> </li> <li> <p>Use <code>paused</code> checkbox to run and pause cubic stylization optimization. If the mesh is too large for real-time optimization, then use <code>Step</code> button to manually run one iteration of the optimization. </p> </li> <li> <p>You can change the <code>cubeness</code> parameter to generate new mesh with different cubic-stylized extent.</p> </li> <li> <p>Rotate three axes to cubic stylize your mesh in different cube orientation.</p> </li> <li> <p>After adding at least two handle points, you can do experiments with as-rigid-as-possible deformation. Use keyboard <code>UP, DOWN, LEFT, RIGHT, SHIFT, SPACE</code> to move your selected handle point up, down, left, right, back, and forward according to the world coordinate. Use <code>TAB</code> to switch between handle points.</p> </li> <li> <p>Use <code>Save mesh</code> button to save your cubic-stylized mesh, the output mesh will be written to the same directory as the input mesh. </p> </li> </ul> <p></p> <ol> <li> <p>Liu, H.-T.D. and Jacobson, A. 2019. Cubic  stylization. ACM Trans. Graph. 38, 6.\u00a0\u21a9</p> </li> </ol>"},{"location":"gallery/","title":"Gallery","text":"CubicCraft turns triangle meshes (grey) into cubic-styled meshes (green) Our GUI, the user can view the mesh deformation progress and change parameters Shape deformation preserves vertex attributes Meshes with different cubeness, we saved our meshes and render them using Blender Meshes with different cube orientation CubicCraft is compatible with As-rigid-as-possible deformation"},{"location":"milestone/","title":"Cubic Craft","text":"<p>Haoda Li,  Puyuan Yi,  Victor Li,  Zhen Jiang</p> <p>In this project, we present a stylization tool to automatically manipulate 3D objects into a cubic style. Our tool uses a cubic stylization algorithm [Liu and Jacobson 2019]1 to cubify the object while preserving the geometric details. With our tool, 3D artists can create Minecraft-styled objects with ease. </p> <p> </p> Cubic Craft turns triangle meshes (grey) into cubic-styled meshes (green)"},{"location":"milestone/#external-links","title":"External Links","text":"<ul> <li>SIGGRAPH styled paper</li> <li>Our slides</li> <li>Our video</li> <li>Our code</li> </ul>"},{"location":"milestone/#install-and-run","title":"Install and Run","text":"<p>We highly encourage you try our GUI. It's based on Python and is very easy to install! The code should support all platforms other than Mac M1 chip.</p> <pre><code>git clone https://github.com/haoda-li/CubicCraft.git\ncd CubicCraft\n\npip install taichi libigl\ncd main\n\n# If you have a Mac or your computer does not have a GPU\n# change gui_taichi.py line 6 \n# from ti.init(arch=ti.gpu)\n# to ti.init(arch=ti.cpu)\npython gui_taichi.py [PATH_TO_MESH_FILE]\n</code></pre>"},{"location":"milestone/#current-progress","title":"Current Progress","text":"<ul> <li>We have successfully finished our base-line algorithm of CPU-based and GPU-based cubic stylization. The GPU implementation is based on <code>libigl</code> and <code>Taichi</code>. Given a mesh, our cubic craft algorithm stylizes the object into a cubic shape. Therefore, the object have a cubic look.</li> <li>We provide a graphical interface for the users to visualize and easily edit the meshes. Given a triangle mesh, our graphical interface allows the user to change the parameters in the algorithm, visualize the deformations, and save the resulting mesh.</li> <li>In addition to the cubeness parameter, we notice that cubic stylization is orientation dependent. The cubeness is achieved by forcing all vertex normals to align with the three standard axes. If we rotate the input mesh, the output shape will be different. Note that the same effect can be achieved by applying a coordinate transformation on all vertex normals. Therefore, we add the coordinate rotation parameters \\((\\theta, \\phi)\\) so that users can have different cube orientations.</li> <li>We did experiments based on several traditional meshes and here are some performance stats:</li> </ul> mesh name number of vertices CPU time (s) GPU time (s) homer 6002 16.03 1.77 bunny 6172 43.23 1.96 armadillo 49990 370.64 7.49"},{"location":"milestone/#future-works","title":"Future works","text":"<ul> <li>Currently, the vertex index and positions are hard-coded. In the future, the users will be able to left-click the mesh and place constraints on the deformation. The users will also be able to drag the points to deform it in real time.</li> <li>Optimizing our user-friendly GUI. The cubic stylization algorithm has many hyperparameters that can be experimented with. Currently our GUI just has the uniform cubeness parameter and cube orientation.</li> <li>Preparing for the final showcase. Creating the video, webpage and writing the final report.</li> </ul>"},{"location":"milestone/#gallery","title":"Gallery","text":"Our GUI, the user can view the mesh deformation progress and change parameters Meshes with different cubeness, we saved our meshes and render them using Blender Meshes with different cube orientation"},{"location":"milestone/#references","title":"References","text":"<ol> <li> <p>Liu, H.-T.D. and Jacobson, A. 2019. Cubic  stylization. ACM Trans. Graph. 38, 6.\u00a0\u21a9</p> </li> </ol>"},{"location":"proposal/","title":"Cubic Craft","text":"<p>Haoda Li,  Puyuan Yi,  Victor Li,  Zhen Jiang, </p> <p>In this project, we present a stylization tool to automatically manipulate 3D objects into a cubic style. Our tool uses a cubic stylization algorithm [Liu and Jacobson 2019]1 to cubify the object while preserving the geometric details. With our tool, 3D artists can create Minecraft-styled objects with ease. </p> <p> </p> Demonstration figure from Cubic Stylization"},{"location":"proposal/#problem-description","title":"Problem Description","text":"<p>Non-realistic modeling can provide a unique art style for animations and video games. One of the most popular area for non-realistic modeling is voxel art. The cube-like looking is very interesting and attractive. There are many 3D editing software that can converts arbitrary meshes to voxels. However, voxelization works on local scale and cannot convert the general geometric shape. In our project, we use a cubic stylization algorithm to stylize the object into a cubic shape. Therefore, the object have a cubic look. </p>"},{"location":"proposal/#goals-and-deliverables","title":"Goals and Deliverables","text":""},{"location":"proposal/#what-we-plan-to-deliver","title":"What we plan to deliver","text":"<p>The final demo will be an interactive GUI for editing and displaying objects. The GUI will provide sliders for tuning the parameters, including cube orientation and \"cubeness\". Because cubic stylization is based on ARAP energy, ARAP deformation comes for free. The user will also be able to set up handle points and deform the object by dragging the points. The GUI will be able to run in real time and show the object's deformation. In addition, we will have an offline renderer to produce ray tracing based images.</p> <p>We are interested in testing the numerical stability and convergence speed of the cubic stylization algorithm. Also, how creative can the cubic style be. </p>"},{"location":"proposal/#what-we-hope-to-deliver","title":"What we hope to deliver","text":"<p>If there are enough time, we are interested in accelerating the algorithm using GPU for more complex meshes. Alternatively, we want to implement mesh decimation so that we we can estimate a simplified mesh, perform cubic stylization, and recover the original mesh after convergence. </p> <p>In addition, we can allow more controls and creativity. For example, the \"cubeness\" can be axis-specific so that the final shape is a cuboid (3D rectangle) instead a right cube. Also, we can expand the algorithm to create other polygon shapes. </p>"},{"location":"proposal/#schedule","title":"Schedule","text":""},{"location":"proposal/#first-week","title":"First week","text":"<ul> <li>Read the paper and investigate the reference code.</li> <li>Write code for the basic cubic stylization algorithm.</li> </ul>"},{"location":"proposal/#second-week","title":"Second week","text":"<ul> <li>Finish and test the basic cubic stylization algorithm.</li> <li>Write the GUI interface and include slides for tuning the parameters.</li> </ul>"},{"location":"proposal/#third-week","title":"Third week","text":"<ul> <li>Fix any existing minor bugs or issues.</li> <li>Work on the stretch goal: accelerating the algorithm using GPU, if we have time.</li> <li>Plug into renderer in order to generate images and record videos for deliverables.</li> </ul>"},{"location":"proposal/#fourth-week","title":"Fourth week","text":"<ul> <li>Finish final deliverables, including project video, project webpage and final paper.</li> <li>Prepare for final demo, including making presentation slides and rehearsal for presentation.</li> <li>Code restructure, improve code readability.</li> </ul>"},{"location":"proposal/#resources","title":"Resources","text":"<p>We will mainly use C++ for the implementation. Ideally, the code will be cross-platform, but we will mainly target at Windows platform. </p> <p>Here is a list of papers and libraries we will use</p> <ul> <li>Cubic Stylization [Liu and Jacobson 2019]1 the algorithm we will use.</li> <li>As-rigid-as-possible surface modeling [Sorkine and Alexa 2007]2 makes the deformation problem an energy minimization problem, and cubic stylization is augmented on ARAP energy. </li> <li>CGAL[@cgal] as the major software platform for CPU implementation. </li> <li>Eigen for linear algebra and sparse solver. </li> <li>ImGUI as the major platform for GUI. </li> <li>Taichi language [Hu et al. 2019]3 If GPU optimization is possible, we can also implement cubic stylization as a Taichi kernel. </li> </ul>"},{"location":"proposal/#references","title":"References","text":"<ol> <li> <p>Liu, H.-T.D. and Jacobson, A. 2019. Cubic  stylization. ACM Trans. Graph. 38, 6.\u00a0\u21a9\u21a9</p> </li> <li> <p>Sorkine, O. and Alexa, M. 2007.  As-rigid-as-possible surface modeling. Proceedings of the fifth  eurographics symposium on geometry processing, Eurographics  Association, 109\u2013116.\u00a0\u21a9</p> </li> <li> <p>Hu, Y., Li, T.-M., Anderson, L., Ragan-Kelley,  J., and Durand, F. 2019. Taichi: A language for high-performance  computation on spatially sparse data structures. ACM Transactions on  Graphics (TOG) 38, 6, 201.\u00a0\u21a9</p> </li> </ol>"},{"location":"report/","title":"CubicCraft: A Mesh Stylization Tool","text":"<p>Haoda Li,  Puyuan Yi,  Victor Li,  Zhen Jiang, </p> <p>Download SIGGRAPH Styled Report  </p>"},{"location":"report/#abstract","title":"Abstract","text":"<p>We present a stylization tool to automatically manipulate triangle meshes into a cubic style. Our tool uses a cubic stylization algorithm [Liu and Jacobson 2019]1 to cubify the user's provided meshes. The algorithm extends the as-rigid-as-possible energy [Sorkine and Alexa 2007]2 with an additional L1 regularization, hence can work seamlessly with ADMM optimization. Cubic stylization works only on the vertex positions, hence preserving the geometrical details and topology. In addition, we implemented the algorithm with GPU acceleration and achieves real-time interactive editing. We also created a user-friendly interaction surface to let users easily change the algorithm's hyperparameter and cubify their own mesh. With our tool, 3D artists can create Minecraft-styled objects with ease.</p> <p> </p> Cubic Craft turns triangle meshes (grey) into cubic-styled meshes (green)"},{"location":"report/#introduction","title":"Introduction","text":"<p>With the increasing availability of image stylization filters and non-photorealistic rendering techniques, creating artistic images has become much more accessible to non-professional users. However, the direct stylization of 3D shapes and non-realistic modeling has not yet been given as much attention. Despite the advancements in technology, professional industries like visual effects and video games still rely on trained modelers to meticulously create non-realistic geometric assets. This is because exploring geometric styles presents a greater challenge, as it involves dealing with arbitrary topologies, curved metrics, and non-uniform discretization. While image stylization tools have made it easier to generate artistic imagery, there is still a lack of effective tools for generating artistic geometry, which remains a major obstacle to the development of geometric stylization.</p> <p>The focus of this paper is on a specific style of sculpture, namely the cubic style. This style has been prevalent throughout art history (ancient sculptures) and modern game history (Minecraft). In this work, we have developed a stylization tool cubic stylization based on GPU that takes a 3D shape as input and outputs a deformed shape that has the same style as cubic sculptures. This tool is aimed at helping artists and designers achieve the cubic style more easily and efficiently, while also providing a new way to explore and experiment with this timeless artistic tradition.</p> <p>Our implemented method cubic stylization formulates the task as an energy optimization problem, which preserves the geometric details of a shape while transforming it into a cubic form. Specifically, this energy function combines an as-rigid-as-possible (ARAP) energy with a special L1 regularization. This energy can be minimized efficiently using the local-global approach with the Alternating Direction Method of Multipliers (ADMM). This method has strong flexibility that allowing artists and designers to achieve a wide range of stylistic variations within the cubic style, providing them with greater creative freedom and expressive potential.</p> <p>Our main contributions are summarized as follows:</p> <ul> <li>We implemented GPU-accelerated cubic stylization algorithm, which allows real-time cubic style object generation and rendering.</li> <li>We created a user-friendly GUI to interact with our algorithm. Users can easily change the hyperparameter of the algorithm and observe different results.</li> </ul>"},{"location":"report/#related-works","title":"Related Works","text":"<p>In this section, our primary focus is on exploring methods for processing geometry. Specifically, we will be discussing various techniques for studying geometric styles and deformation methods that share common technical similarities. Our aim is to provide a comprehensive overview of these methods and their applications and to highlight their significance in the field of geometry processing.</p>"},{"location":"report/#shape-deformation","title":"Shape Deformation","text":"<p>The subfield of shape deformation has been the subject of considerable research in computer graphics and related fields. Several notable works have contributed to this area, including the as-rigid-as-possible (ARAP) energy model [Sorkine and Alexa 2007]2, which has become a popular method for shape deformation due to its ability to preserve the rigid structure of the object being deformed. Another important contribution is the Laplacian-based deformation technique [Sorkine et al. 2004]3, which uses the Laplacian operator to deform a shape while preserving its surface details. In addition, several works have explored the use of physically-based deformation models, such as the finite-element method and the mass-spring system [Nealen et al. 2006]4.</p> <p>More recent work in shape deformation has focused on extending these techniques to handle more complex shapes and deformation scenarios. For example, the Cage-based deformation method [Le and Deng 2017]5 uses a cage mesh to define the deformation space, allowing for more intuitive and flexible deformation. Other works have explored the use of machine learning techniques, such as neural networks, for shape deformation [Li et al. 2022]6.</p> <p>The subfield of shape deformation has made significant contributions to the field of computer graphics and related disciplines and continues to be an active area of research with numerous exciting directions for future exploration. Our cubic stylization is also a specific kind of shape deformation that combines ARAP energy term and a L1 regularization term.</p> <p> </p> Shape deformation preserves vertex attributes"},{"location":"report/#different-geometric-style","title":"Different Geometric Style","text":"<p>Research on different geometric styles has been a topic of interest in computer graphics and related fields. Two main approaches have been taken to explore this area: discriminative geometric styles and generative geometric styles.</p> <p>Discriminative geometric styles focus on identifying and analyzing different styles in existing geometry. For example, the work by Kim et al. [Kim et al. 2013]7 proposes a method for identifying and characterizing different geometric styles in furniture design, while the work by Zhou et al. [Zhou et al. 2016]8 focuses on identifying different styles in fashion design.</p> <p>On the other hand, generative geometric styles aim to create new geometry in a particular style. One notable example is the work by Huang et al.  [Huang et al. 2018]9, which proposes a method for generating 3D models in a particular style using a generative adversarial network (GAN). Another example is the work by Kalogerakis et al. [Kalogerakis et al. 2012]10, which uses a probabilistic model to generate 3D shapes with a particular style.</p> <p>Overall, research on different geometric styles has led to a deeper understanding of the principles and characteristics of different styles in various domains, as well as the development of methods for creating new geometry in a particular style. These techniques have potential applications in a variety of fields, such as architecture, product design, and entertainment.</p>"},{"location":"report/#method","title":"Method","text":"<p>Our method is based on cubic stylization [Liu and Jacobson 2019]1, a method to deform the input mesh into a cubic stylized mesh. Generally, the method adds a new L1 regularization on the deformation with As-rigid-as-possible (ARAP) [Sorkine and Alexa 2007]2 energy optimization. By regularizing each vertex normal to align with the axis, the mesh can have a cubic style, while maintaining the local geometric details.</p> <p>The problem description is illustrated as follows: given a triangle mesh \\(S = (V, F)\\) and a set of constraints on vertex positions. We want to output a deformed shape \\(\\tilde V\\). The output shape will have each sub-component in the style of axis-aligned cubes and will retain the geometric details of the original mesh. </p> <p>We will describe our method and implementation in the following sections: In As-rigid-as-possible Deformation section, we will talk about the As-rigid-as-possible (ARAP) Deformation [Sorkine and Alexa 2007]2, and elaborate on its energy functions. Then we will talk about cubic stylization [Liu and Jacobson 2019]1 in Cubic Stylization section. The implementation part is in Implementation section.</p>"},{"location":"report/#as-rigid-as-possible-deformation","title":"As-rigid-as-possible Deformation","text":"Cubified Mesh with as-rigid-as-possible deformation <p>The thought of ARAP energy is very intuitive: given the cell \\(C_i\\) corresponding to vertex \\(i\\), and its deformed version \\(\\tilde C_i\\), ARAP defines the approximate rigid transformation between the two cells by observing the edges emanating from the vertex \\(i\\) in \\(S\\) and \\(\\tilde S\\), where \\(S\\) and \\(\\tilde S\\) denote the original triangle mesh and the deformed triangle mesh. Note that \\(\\tilde S\\) should have the same connectivity as \\(S\\). If the deformation \\(C_i \\rightarrow \\tilde C_i\\) is rigid, there must exists a rotation matrix \\(R_i\\) such that:</p> \\[\\tilde V_i - \\tilde V_j = R_i(V_i - V_j),  \\forall j \\in \\mathcal N(i)\\] <p>$ \\mathcal N(i)$ denotes the set of vertices connected to vertex \\(i\\), also called the one-ring neighbors. </p> <p>When the deformation is not rigid, we can still find the best approximating rotation matrix \\(R_i\\) that fits the above equations in a weighted least squares sense,  i.e., minimizes</p> \\[E(C_i, \\tilde C_i) = \\sum_{i\\in V}\\sum_{j\\in \\mathcal N(i)} w_{ij} \\|R_i d_{ij} -  \\tilde{d_{ij}}\\|_F^2\\] <p>where \\(w_{ij}\\) is the cotangent weight [Pinkall and Polthier 1993]11 between vertex \\(i\\) and vertex \\(j\\), and \\(d_{ij} = V_i - V_j\\) and \\(\\tilde d_{ij} = \\tilde V_i - \\tilde V_j\\). What we need is to solve for vertex position \\(\\tilde V_i\\) and per-vertex rotations \\(R_i\\) that minimizes the energy function above. </p> <p>For deformation, we are given user-defined constraints on some vertex positions and we need to update all other vertices to minimize the energy. [Sorkine and Alexa 2007]2 uses alternating minimization strategy. For each iteration, we first fix vertex positions to find the optimal rotations for each vertex, and then fix the rotations to update vertex positions. The rotation updates only depends on the one-ring neighbor for each vertex, hence we call it a local step. We will talk more details about local steps in the next section. The vertices update, or the global step, can be directly derived by setting the partial derivative w.r.t. each vertex position to \\(0\\). Eventually, we need to solve a system of \\(3N\\) equations of \\(3N\\) unknowns, where each vertex corresponds to the equation </p> \\[\\sum_{j\\in \\mathcal N(i)} w_{ij} \\tilde{d_{ij}} = \\sum_{j\\in \\mathcal N(i)} \\frac{w_{ij}}{2} (R_i+R_j)d_{ij}\\]"},{"location":"report/#cubic-stylization","title":"Cubic Stylization","text":"<p>In this section, we will illustrate the cubic stylization algorithm. Intuitively, an object is cubic style if its normals are aligned with the three dominant directions. Therefore, [Liu and Jacobson 2019]1 proposed an additional L1 regularization term on the rotated normal. Combining with the ARAP energy, the full energy term is listed as follows:</p> \\[E(C_i, C_i^{\\prime}) = \\sum_{i\\in V}\\sum_{j\\in \\mathcal N(i)} \\frac{w_{ij}}{2}\\|R_id_{ij} - \\tilde d_{ij}\\|_F^2 + \\lambda a_i \\|R_i\\tilde n_i\\|_1\\] <p>In the L1 regularization term, \\(\\hat n_i\\) denotes the area-weighted unit normal vector of \\(v_i\\) and \\(a_i\\) is the barycentric area of \\(v_i\\). and \\(\\lambda\\) is the \"cubeness\" parameter.</p> <p>The local step involves finding the rotation matrix \\(R_1,\\cdots, R_n\\), for each vertex \\(i\\), we are to optimize:</p> \\[R_i^* = \\arg\\min_{R_i\\in SO(3)}\\sum_{j\\in \\mathcal N(i)} \\frac{w_{ij}}{2}\\|R_id_{ij} - \\tilde d_{ij}\\|_F^2 + \\lambda a_i \\|R_i\\tilde n_i\\|_1\\] <p>note that the ARAP energy can be expressed in matrix formations </p> \\[\\frac12 (R_iD_i-\\tilde D_i)^T W_i (R_iD_i-\\tilde D_i) = \\frac12\\|R_iD_i-\\tilde D_i\\|_{W_i}^2\\] <p>where \\(D_i,\\tilde D_i \\in \\mathbb R^{3\\times |\\mathcal N(i)|}\\) are stacked rim/spoke edge vectors and \\(W_i\\) is the diagonal matrix of \\(w_1,...,w_n\\). Then, write \\(z = R_i\\hat n_i\\), we can turn the formation into</p> \\[\\begin{align*} \\text{minimize}_{z_, R_i} \\quad &amp;\\frac12 \\|R_iD_i-\\tilde D_i\\|_{W_i}^2+\\lambda a_i\\|z\\|_1\\\\ \\text{subject to} \\quad &amp;z-R_i\\hat n_i = 0 \\end{align*}\\] <p>Now We can solve the local step using the alternating direction method of multipliers (ADMM) updates [@admm}. Applying ADMM, the update steps are</p> \\[\\begin{align*} R_i^{k+1} &amp;= \\arg\\min \\frac12\\|R_iD_i-\\tilde D_i\\|_{W_i}^2 + \\frac{\\rho^k}2\\|R_i\\hat n_i - z^k + u^k\\|_2^2\\\\ z^{k+1} &amp;= \\arg\\min \\lambda a_i \\|z\\|_1 + \\frac{\\rho^k}2\\|R_i^{k+1} \\hat n_i - z + u^k\\|_2^2\\\\ \\tilde u^{k+1} &amp;= u^k + R_i^{k+1} \\hat n_i - z^{k+1}\\\\ \\rho^{k+1}, u^{k+1} &amp;= \\text{update}(\\rho^k)    \\end{align*}\\] <p>Then, consider each update, The rotation update can be viewed as </p> \\[R_i^{k+1} = \\arg\\max tr(R_i M_i)\\] \\[M_i = \\begin{bmatrix}[D_i]&amp;[\\hat n_i]\\end{bmatrix} \\begin{bmatrix}[W_i]&amp;0\\\\0&amp;\\rho^k\\end{bmatrix} \\begin{bmatrix}[\\tilde D_i]\\\\ [(z^k-u^k)^T] \\end{bmatrix}\\] <p>This becomes an Orthogonal Procrustes problem, and the solution is given through single value decomposition</p> \\[M = U\\Sigma V^T, R = UV^T\\] <p>up to \\(\\det(R) &gt; 0\\) by alternating the sign of \\(U\\)'s column. The \\(z\\) update is an instance of lasso problem, which can be solved with a shrinkage step</p> \\[z^{k+1} = S_{\\lambda a_i/\\rho^k}(R_i^{k+1}\\hat n_i + u^k)\\] <p>where the shrinkage is defined as </p> \\[S_\\chi(x_j) = (1-\\frac{\\chi}{|x_j|}) + x_j\\] <p>Hence we solve the local step. Then, we notice that L1 term \\(\\lambda a_i\\|R_i\\tilde n_i\\|_1\\) is independent of the vertex positions \\(V\\). Therefore, the global step is exactly the same as ARAP energy optimization.</p> <p> </p> Meshes with different cubeness"},{"location":"report/#implementation","title":"Implementation","text":"<p>We implement the cubic stylization [Liu and Jacobson 2019]1 algorithm using Python and <code>libigl</code> [Jacobson et al. 2018]12. We follow [Liu and Jacobson 2019]1's implementation and set the initial \\(\\rho = 10^{-4}, \\mu=50, \\tau=2\\). In addition, we observe that the local step updates each vertex independently, providing opportunities for parallelization. We use <code>Taichi</code> [Hu et al. 2019]13 to implement a GPU-accelerated version. To maximize parallelism, for each local step, we run a fixed number of ADMM iterations instead of using the stopping criteria. We set the initial ADMM iterations to \\(50\\) and reduce it to \\(5\\) through the steps. From experiments, we found that this strategy is adequate for convergence. </p> <p>Compared to the CPU implementation [Liu and Jacobson 2019]1, our implementation gradually accelerated the local step computation. We tested our implementation on an <code>AMD R9 5900HS CPU</code> with a <code>NVIDIA 3050ti GPU</code> and listed the performance below. </p> Mesh name Num. vertices CPU time (s) GPU time (s) homer 6002 10.03 3.39 bunny 6172 27.56 3.55 owl 39416 160.52 6.69 horse 48485 211.62 8.25 armadillo 49990 217.96 7.80 dragon 62472 335.71 9.16"},{"location":"report/#user-interface","title":"User Interface","text":"Our GUI, the user can view the mesh deformation progress and change parameters <p>We provide a graphical interface for the users to visualize and easily edit the meshes. The graphical interface is based on the GUI system provided by <code>Taichi</code>. Given a triangle mesh, our graphical interface allows the user to change the parameters in the algorithm, visualize the deformations, and save the resulting mesh. </p> <p>In our GUI, the user can directly change the <code>cubeness</code> parameter and observe different results in real-time. Note that our algorithm only changes the vertex position, hence other local geometric information, such as texture coordinates, is preserved. In addition to the <code>cubeness</code> parameter, we notice that cube stylization is orientation dependent. The cubeness is achieved by forcing all vertex normals to align with the three standard axes. If we rotate the input mesh, the output shape will be different. Note that the same effect can be achieved by applying a coordinate transformation on all vertex normals. Therefore, we add the <code>coordinate rotation</code> parameters so that users can have different cube orientations. </p> <p> </p> Meshes with different cube orientation <p>Similar to [Sorkine and Alexa 2007]2's approach, we can put constraints on vertex positions. Users can utilize our GUI to add handle points and move the handle points to perform as-rigid-as-possible deformation. Note that natural deformations are obtained because the optimization automatically produces the correct local rotations for each vertex. </p>"},{"location":"report/#conclusion","title":"Conclusion","text":"<p>In conclusion, our work presents a powerful tool for cubic stylization that enables 3D artists to create Minecraft-styled objects with ease. Our algorithm, which extends the as-rigid-as-possible energy with an L1 regularization, works seamlessly with ADMM optimization and preserves the underlying geometrical details and topology of the mesh. Furthermore, our implementation with GPU acceleration allows for real-time interactive editing, making the tool both efficient and intuitive to use.</p> <p>Overall, our work contributes to the growing field of geometry processing by presenting a novel approach to stylization. The ability to manipulate and transform meshes in a cubic style has significant potential for a range of applications, including architectural design, game development, and animation. We believe that our tool will be particularly valuable to 3D artists who wish to create unique and visually striking objects quickly and efficiently.</p>"},{"location":"report/#references","title":"References","text":"<ol> <li> <p>Liu, H.-T.D. and Jacobson, A. 2019. Cubic  stylization. ACM Trans. Graph. 38, 6.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Sorkine, O. and Alexa, M. 2007.  As-rigid-as-possible surface modeling. Proceedings of the fifth  eurographics symposium on geometry processing, Eurographics  Association, 109\u2013116.\u00a0\u21a9\u21a9\u21a9\u21a9\u21a9\u21a9</p> </li> <li> <p>Sorkine, O., Cohen-Or, D., Lipman, Y., Alexa,  M., Rossl, C., and Seidel, H.-P. 2004. Laplacian surface editing.  Proceedings of the 2004 eurographics/ACM SIGGRAPH symposium on geometry  processing, Association for Computing Machinery, 175\u2013184.\u00a0\u21a9</p> </li> <li> <p>Nealen, A., Muller, M., Keiser, R., Boxerman,  E., and Carlson, M. 2006. Physically based deformable models in  computer graphics. Comput. Graph. Forum 25, 809\u2013836.\u00a0\u21a9</p> </li> <li> <p>Le, B.H. and Deng, Z. 2017. Interactive  cage generation for mesh deformation. Proceedings of the 21st ACM  SIGGRAPH symposium on interactive 3D graphics and games, Association  for Computing Machinery, 1\u20139.\u00a0\u21a9</p> </li> <li> <p>Li, J., Du, X., and Martins, J.R.R.A.  2022. Machine learning in aerodynamic shape optimization. Progress in  Aerospace Sciences 134, 100849.\u00a0\u21a9</p> </li> <li> <p>Kim, H., Jung, S., Lee, S., and Lee, K.  2013. Identification and characterization of different geometric styles  in furniture design. International Journal of Advanced Manufacturing  Technology 69, 5-8, 1079\u20131093.\u00a0\u21a9</p> </li> <li> <p>Zhou, Y., Xu, B., Guo, Y., and Liu, Y.  2016. Fashion style identification based on convolutional neural  networks. Proceedings of the 2016 ACM on multimedia conference,  Association for Computing Machinery (ACM), 682\u2013686.\u00a0\u21a9</p> </li> <li> <p>Huang, Y., Li, H., Sun, X., and Wu, Y.  2018. 3D model generation in a specific style using GAN. Proceedings of  the 2018 ACM multimedia conference, Association for Computing Machinery  (ACM), 1648\u20131656.\u00a0\u21a9</p> </li> <li> <p>Kalogerakis, E., Winnemoeller, H., and Malik,  J. 2012. Probabilistic reasoning for assembly-based 3D modeling.  ACM Transactions on Graphics (TOG) 31, 4, 51.\u00a0\u21a9</p> </li> <li> <p>Pinkall, U. and Polthier, K. 1993.  Computing discrete minimal surfaces and their conjugates. Experimental  mathematics 2, 1, 15\u201336.\u00a0\u21a9</p> </li> <li> <p>Jacobson, A., Panozzo, D., and others.  2018. libigl: A simple C++ geometry  processing library.\u00a0\u21a9</p> </li> <li> <p>Hu, Y., Li, T.-M., Anderson, L., Ragan-Kelley,  J., and Durand, F. 2019. Taichi: A language for high-performance  computation on spatially sparse data structures. ACM Transactions on  Graphics (TOG) 38, 6, 201.\u00a0\u21a9</p> </li> </ol>"}]}